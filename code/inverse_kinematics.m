function thetad = inverse_kinematics(u)% performs inverse kinematics computations with various methods% Stefan Schaal, March 2009% split the input u into meaningful quantitiesn = (length(u)-2)/2;theta = u(1:n);xd    = u(n+1:n+2);links = u(n+3:end);n = length(theta);m = length(xd);% NOTE: insert your Jacobian calculation here% J = ????;px1 = -4/4*links(1)*sin(theta(1))-3/4*links(2)*sin(theta(1)+theta(2)) - 2/4*links(3)*sin(sum(theta(1:3))) - 1/4*links(4)*sin(sum(theta));px2 = -3/4*links(2)*sin(theta(1)+theta(2)) - 2/4*links(3)*sin(sum(theta(1:3))) - 1/4*links(4)*sin(sum(theta));px3 = -2/4*links(3)*sin(sum(theta(1:3))) - 1/4*links(4)*sin(sum(theta));px4 = -1/4*links(4)*sin(sum(theta));py1 = 4/4*links(1)*cos(theta(1)) + 3/4*links(2)*cos(theta(1)+theta(2)) + 2/4*links(3)*cos(sum(theta(1:3))) + 1/4*links(4)*cos(sum(theta));py2 = 3/4*links(2)*cos(theta(1)+theta(2)) + 2/4*links(3)*cos(sum(theta(1:3))) + 1/4*links(4)*cos(sum(theta));py3 = 2/4*links(3)*cos(sum(theta(1:3))) + 1/4*links(4)*cos(sum(theta));py4 = 1/4*links(4)*cos(sum(theta));J = [px1,px2,px3,px4;     py1,py2,py3,py4];% convert cartesian velocities into joint velocities% NOTE: insert the required inverse kinematics methods at this%       location% thetad = ????;alpha = 0.01;% g 0.3% thetad = alpha*J'*xd;% h% thetad = alpha*J'*inv(J*J')*xd;% i% J_ = J'*inv(J*J');% thetad = alpha*J_*xd + (eye(4) - J_*J)*(0.1*ones(4,1)-theta);% j% w=[1.0 0.5 0.1 0.01]';% J_ = J'*inv(J*J');% thetad = alpha*w.*(J'*inv(J*J')*xd);% k% w=[1.0 0.5 0.1 0.01]';% J_ = J'*inv(J*J');% thetad = alpha*(J_*xd) + 0.01*w.*((eye(4) - J_*J)*(0.1*ones(4,1)-theta));